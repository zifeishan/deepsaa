deepdive {

  # #############
  # CONFIGURATION
  # #############
  db.default {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}  #"
    user: ${PGUSER}
    password: ${PGPASSWORD}
  }

  sampler.sampler_cmd: "util/sampler-dw-linux gibbs"
  sampler.sampler_args: "-l 1000 -s 1 -i 1000 --alpha 1.0 --diminish 0.99"
  # sampler.sampler_args: "-l 300 -s 1 -i 500 --alpha 0.001"
  # sampler.sampler_args: "-l 0 -s 1 -i 0 --alpha 0.01"

  # pipeline.relearn_from: "/lfs/madmax2/0/zifei/deepdive/out/2014-04-28T152335/"

  # ###########
  # CALIBRATION
  # ###########
  # calibration.holdout_fraction: 0.25
  calibration.holdout_query: """INSERT INTO dd_graph_variables_holdout(variable_id) 
     select id from publication_author where is_true = true limit 200;

     INSERT INTO dd_graph_variables_holdout(variable_id) 
     select id from publication_author where is_true = false and random() < 0.25;
     """

  # ##############
  # FREE VARIABLES
  # ##############
  schema.variables {
    # publication_author.is_true: Boolean 
    # TODO
    sentence_author.is_true: Boolean
  }

  # ###########
  # DEBUGGING
  # ###########
  pipeline.run: "imported"

  # All we need is just to run "bash preprocess/import... then run"
  pipeline.pipelines.imported: [
    "ext_sentence_author",
    "ext_publication_author",
    "ext_imported_sentences_labeling",

    # Features
    "ext_sentence_stats",
    "ext_char_1gram",
    "ext_char_2gram",
    "ext_word_1gram",
    "ext_word_3gram",

    # Export features
    "ext_export_json_sentence",
    "ext_export_json_sentence_copy",
    "ext_export_json_pub",
    "ext_export_json_pub_copy",

    # Doc level inference
    # "f_doc_stats",
    # "f_char_1gram",
    # "f_char_2gram",
    # "f_word_1gram",
    # "f_word_3gram",

    # Sentence level inference
    # "f_doc_stats",
    # "f_char_1gram",
    # "f_char_2gram",
    # "f_word_1gram",
    # "f_word_3gram",

  ]
  pipeline.pipelines.all: [
    # "ext_supv_author_list",

    # NLP extraction on all sentences
    # "ext_sentences_nlp",
    # "ext_sentence_author",
    "ext_prepare_supervision", "ext_positive_example", "ext_negative_example",

    # Features
    # "ext_sentence_stats",
    # "ext_char_1gram",
    # "ext_char_2gram",
    # "ext_word_1gram",
    # "ext_word_3gram",
    # "ext_pos_2gram",
    # "ext_doc_stats",

    # Export features
    # "ext_export_json_sentence",
    # "ext_export_json_sentence_copy",
    # "ext_export_json_pub",
    # "ext_export_json_pub_copy",

    # Doc level inference
    "f_doc_stats",
    "f_char_1gram",
    "f_char_2gram",
    "f_word_1gram",
    "f_word_3gram",

  ]


  # ##########
  # Extractors
  # ##########
  extraction.extractors {

    ########### 
    # Prepare tables before extraction:
    # corpus(id bigint): Contains all publication ids we care. 
    # authors(author_id bigint): Contains all author_id we care. 

    # Extract sentence NLP Tags from articles
    ext_sentences_nlp {
      input: """
          SELECT p.id AS publication_id,
                description
          FROM meta_publications p, corpus t
          WHERE p.id = t.id and 
            not exists (select * from sentences where document_id = p.id)
          ORDER BY publication_id ASC
        """
      output_relation: "sentences"
      udf: "bash "${DEEPDIVE_HOME}"/examples/nlp_extractor/run.sh -k publication_id -v description -l 20 -t 4"
      before: ${APP_HOME}"/udf/before_sentences.sh"
      after: ${DEEPDIVE_HOME}"/examples/spouse_example/script/fill_sequence.sh sentences sentence_id"
      input_batch_size: 10
      output_batch_size: 1000
      parallelism: ${PARALLELISM}
    }

    # Prepare "supervised_author_names" table before this
    # Select all authors in the list, and their co-authors
    ext_supv_author_list {
      style: "sql_extractor"
      sql: """
        DROP TABLE IF EXISTS authors CASCADE;

        SELECT id as author_id, name
        INTO authors 
        FROM meta_authors 
        WHERE name IN (select name from supervised_author_names);

        DROP TABLE IF EXISTS corpus CASCADE;

        SELECT  distinct publication_id as id 
        INTO    corpus
        FROM    publication_authors 
        WHERE   author_id in (select author_id from authors);

        INSERT INTO authors
        SELECT  distinct meta_authors.id, meta_authors.name
        FROM    publication_authors m,
                corpus c,
                meta_authors
        WHERE   m.publication_id = c.id
          AND   meta_authors.id = m.author_id
          AND   NOT EXISTS (
              SELECT * FROM authors 
              WHERE authors.author_id = m.author_id)

      """
    }


    # Create the prediction matrix
    # TODO Fix bigserial for faster grounding 
    # TODO: sentence_id column name
    # DISTRIBUTED BY (publication_id);
    ext_sentence_author {
      style: "sql_extractor"
      dependencies: ["ext_sentences_nlp", "ext_supv_author_list"]
      sql: """
        DROP TABLE IF EXISTS sentence_author CASCADE;

        CREATE TABLE sentence_author (
            publication_id bigint,
            sentence_id bigint,
            author_id bigint,
            is_true boolean,
            id bigint
          );

        INSERT INTO sentence_author (sentence_id, publication_id, 
                author_id)
        SELECT  sentence_id, 
                document_id AS publication_id, 
                authors.author_id
          FROM  sentences, authors;
      """
    }

    # Create the prediction matrix
    ext_publication_author {
      style: "sql_extractor"
      dependencies: ["ext_sentences_nlp", "ext_supv_author_list"]
      sql: """
        DROP TABLE IF EXISTS publication_author CASCADE;

        CREATE TABLE publication_author (
            publication_id bigint,
            author_id bigint,
            is_true boolean,
            id bigint
          ) DISTRIBUTED BY (publication_id);

        INSERT INTO publication_author (publication_id, 
                author_id, is_true)
        SELECT  corpus.id AS publication_id, 
                authors.author_id,
                null::boolean is_true
          FROM  corpus, authors;
      """
    }


    # DRPRECATED. Users have to prepare "publication_authors" beforehand.
    # # TODO meta_publication_authors -> publication_authors
    # ext_prepare_supervision {
    #   style: "sql_extractor"
    #   dependencies: ["ext_sentence_author", "ext_publication_author"]
    #   sql:"""
    #     DROP TABLE IF EXISTS publication_authors CASCADE;
    #     CREATE TABLE publication_authors AS 
    #     SELECT p.*
    #     FROM publication_authors p, corpus t 
    #     WHERE t.id = p.publication_id
    #     DISTRIBUTED BY (publication_id);
    #     """
    # }

    ext_imported_sentences_labeling {
      style: "sql_extractor"
      dependencies: ["ext_sentence_author", "ext_publication_author"]
      sql: """
        UPDATE  sentence_author 
           SET  is_true = true
          FROM  sentences s,
                meta_authors
         WHERE  sentence_author.publication_id = s.document_id
           AND  sentence_author.sentence_id = s.sentence_id
           AND  author_id = meta_authors.id
           AND  author_name = meta_authors.name;

        UPDATE  sentence_author 
           SET  is_true = false
         WHERE  is_true is null;

        UPDATE  publication_author
           SET  is_true = true
          FROM  publication_authors pa
         WHERE  publication_author.publication_id = pa.publication_id
           AND  publication_author.author_id = pa.author_id;
           
        UPDATE  publication_author
           SET  is_true = false
         WHERE  is_true is null;
      """
    }

    # Set Single_author_papers as positive examples
    # 2119 positive examples
    ext_positive_example {
      style: "sql_extractor"
      dependencies: ["ext_prepare_supervision"]
      sql: """
        DROP TABLE IF EXISTS publication_author_count CASCADE;

        CREATE TABLE publication_author_count 
        AS 
          SELECT t.id AS publication_id, COUNT(author_id) AS num_authors FROM corpus t, publication_authors 
        WHERE t.id = publication_id GROUP BY (t.id) 
        DISTRIBUTED BY (publication_id);

        UPDATE  sentence_author 
           SET  is_true = true
          FROM  publication_author_count c,
                publication_authors a
         WHERE  a.publication_id = c.publication_id
           AND  c.publication_id = sentence_author.publication_id
           AND  a.author_id = sentence_author.author_id
           AND  c.num_authors = 1 ;

        UPDATE  publication_author 
           SET  is_true = true
          FROM  publication_author_count c,
                publication_authors a
         WHERE  a.publication_id = c.publication_id
           AND  c.publication_id = publication_author.publication_id
           AND  a.author_id = publication_author.author_id
           AND  c.num_authors = 1 ;

      """
    }

    # Set ALL non-authored papers as negative examples
    # 3539102 negative examples
    ext_negative_example {
      style: "sql_extractor"
      dependencies: ["ext_prepare_supervision"]
      sql: """
        UPDATE  sentence_author 
           SET  is_true = false
         WHERE  NOT EXISTS (
            SELECT  * 
            FROM    publication_authors a
            WHERE   a.publication_id =  sentence_author.publication_id
              AND   a.author_id = sentence_author.author_id
        );

        UPDATE  publication_author 
           SET  is_true = false
         WHERE  NOT EXISTS (
            SELECT  * 
            FROM    publication_authors a
            WHERE   a.publication_id =  publication_author.publication_id
              AND   a.author_id = publication_author.author_id
        );
      """
    }


    ext_sentence_stats {
      style: "plpy_extractor"
      dependencies: ["ext_sentences_nlp"]
      input: """
        select sentence_id, document_id, sentence, words
        from sentences
      """
      output_relation: "f_sentence_stats"
      udf: ${APP_HOME}"/udf/ext_sentence_stats.py"
      before: ${APP_HOME}"/udf/before_sentence_stats.sh"
    }

    # Select character Ngrams (N is 3rd input in the query / before / output_relation)
    ext_char_1gram {
      style: "plpy_extractor"
      dependencies: ["ext_sentences_nlp"]
      input: """
        select sentence_id, document_id, sentence, 1 as gram_len
        from sentences
      """
      output_relation: "f_char_1gram"
      udf: ${APP_HOME}"/udf/ext_char_ngram.py"
      before: ${APP_HOME}"/udf/before_char_ngram.sh 1"
    }

    # Select character Ngrams (N is 3rd input in the query / before / output_relation)
    ext_char_2gram {
      style: "plpy_extractor"
      dependencies: ["ext_sentences_nlp"]
      input: """
        select sentence_id, document_id, sentence, 2 as gram_len
        from sentences
      """
      output_relation: "f_char_2gram"
      udf: ${APP_HOME}"/udf/ext_char_ngram.py"
      before: ${APP_HOME}"/udf/before_char_ngram.sh 2"
    }

    # Select character Ngrams (N is 3rd input in the query)
    ext_word_1gram {
      style: "plpy_extractor"
      dependencies: ["ext_sentences_nlp"]
      input: """
        select sentence_id, document_id, words, 1 as gram_len
        from sentences
      """
      output_relation: "f_word_1gram"
      udf: ${APP_HOME}"/udf/ext_word_ngram.py"
      before: ${APP_HOME}"/udf/before_word_ngram.sh 1"
    }

    # Select word Ngrams (N is 3rd input in the query)
    ext_word_3gram {
      style: "plpy_extractor"
      dependencies: ["ext_sentences_nlp"]
      input: """
        select sentence_id, document_id, words, 3 as gram_len
        from sentences
      """
      output_relation: "f_word_3gram"
      udf: ${APP_HOME}"/udf/ext_word_ngram.py"
      before: ${APP_HOME}"/udf/before_word_ngram.sh 3"
    }

    # Select pos Ngrams (N is 3rd input in the query)
    ext_pos_2gram {
      style: "plpy_extractor"
      dependencies: ["ext_sentences_nlp"]
      input: """
        select sentence_id, document_id, pos_tags, 2 as gram_len
        from sentences
      """
      output_relation: "f_pos_2gram"
      udf: ${APP_HOME}"/udf/ext_word_ngram.py"
      before: ${APP_HOME}"/udf/before_pos_ngram.sh 2"
    }

    ############# Document-level ##############

    # Doc length, # words, avg length of words.
    ext_doc_stats {
      style: "plpy_extractor"
      dependencies: ["ext_sentences_nlp"]
      input: """
        select id, datestamp, title, description 
        from corpus natural join meta_publications
      """
      output_relation: "f_doc_stats"
      udf: ${APP_HOME}"/udf/ext_doc_stats.py"
      before: ${APP_HOME}"/udf/before_doc_stats.sh"
    }

    # ext_doc_stats_toy_corpus {
    #   style: "plpy_extractor"
    #   dependencies: ["ext_sentences_nlp"]
    #   input: """
    #     select id, '', '', array_agg(sentence) TODO!!

    #     from sentence, corpus natural join meta_publications
    #   """
    #   output_relation: "f_doc_stats"
    #   udf: ${APP_HOME}"/udf/ext_doc_stats.py"
    #   before: ${APP_HOME}"/udf/before_doc_stats.sh"
    # }

    ########### EXPORT JSON BY SENTENCE #############

    ext_export_json_sentence {
      style: "plpy_extractor"
      dependencies: ["ext_sentence_stats", "ext_char_1gram", "ext_char_2gram", "ext_word_1gram", "ext_word_3gram", "ext_pos_2gram", "ext_doc_stats", "ext_imported_sentences_labeling"]
      output_relation: "export_features"
      udf: ${APP_HOME}"/udf/ext_export_json.py"
      before: ${APP_HOME}"/udf/before_export_json.sh"

          # (SELECT s.id as sentence_id, 
          #         s.document_id as publication_id,
          #         'doc' as fname_prefix, 
          #         array_agg(fname) as fname, 
          #         array_agg(fval) as fval
          #   FROM  f_doc_stats f,
          #         sentences s
          #   WHERE f.publication_id = s.document_id
          #   GROUP BY s.document_id, s.id)
          # UNION
      input: """
      SELECT 
        sentence_id,
        publication_id,
        fname_prefix,
        fname,
        fval
        FROM 
        (

          (SELECT sentence_id, publication_id,
                  'sen' as fname_prefix, 
                  array_agg(fname) as fname, 
                  array_agg(fval)  as fval
            FROM  f_sentence_stats
            GROUP BY publication_id, sentence_id)
          UNION
          
          (SELECT sentence_id, publication_id, 
                  'c1' as fname_prefix, 
                  array_agg(ngram) as fname,
                  array_agg(count) as fval
            FROM  f_char_1gram 
            GROUP BY publication_id, sentence_id)
          UNION
          (SELECT sentence_id, publication_id,
                  'c2' as fname_prefix, 
                  array_agg(ngram) as fname,
                  array_agg(count) as fval
            FROM  f_char_2gram 
            GROUP BY publication_id, sentence_id)
          UNION
          (SELECT sentence_id, publication_id,
                  'w1' as fname_prefix, 
                  array_agg(ngram) as fname,
                  array_agg(count) as fval
            FROM  f_word_1gram 
            GROUP BY publication_id, sentence_id)
          UNION
          (SELECT sentence_id, publication_id,
                  'w3' as fname_prefix, 
                  array_agg(ngram) as fname,
                  array_agg(count) as fval
            FROM  f_word_3gram 
            GROUP BY publication_id, sentence_id)
        ) tmp
      """
    }

    ext_export_json_sentence_copy {
      style: "sql_extractor"
      dependencies: ["ext_export_json_sentence"]
      sql: """
        COPY(
            select * from export_features
            order by publication_id, sentence_id)
          to '/tmp/deepsaa-sentence-features.tsv';

        DROP TABLE IF EXISTS eval_sentence_authors CASCADE;

        SELECT sentence_id, publication_id, array_agg(distinct author_id) as authors 
        INTO eval_sentence_authors 
        FROM sentence_author where IS_TRUE != false or is_true is null group by publication_id, sentence_id;

        COPY(
          select * from eval_sentence_authors
            order by publication_id, sentence_id)
          to '/tmp/deepsaa-sentence-authors.tsv';

      """
    }

    ext_export_json_pub {
      style: "plpy_extractor"
      dependencies: ["ext_sentence_stats", "ext_char_1gram", "ext_char_2gram", "ext_word_1gram", "ext_word_3gram", "ext_pos_2gram", "ext_doc_stats"]
      output_relation: "export_features_pub"
      udf: ${APP_HOME}"/udf/ext_export_json_pub.py"
      before: ${APP_HOME}"/udf/before_export_json_pub.sh"
          # (SELECT publication_id,
          #         'doc' as fname_prefix, 
          #         array_agg(fname) as fname, 
          #         array_agg(fval) as fval
          #   FROM  f_doc_stats f
          #   GROUP BY publication_id)
          # UNION

      input: """
      SELECT 
        publication_id,
        fname_prefix,
        fname,
        fval
        FROM 
        (
          (SELECT publication_id, 
                  'c1' as fname_prefix, 
                  array_agg(ngram) as fname,
                  array_agg(count) as fval
            FROM  f_char_1gram 
            GROUP BY publication_id)
          UNION
          (SELECT publication_id,
                  'c2' as fname_prefix, 
                  array_agg(ngram) as fname,
                  array_agg(count) as fval
            FROM  f_char_2gram 
            GROUP BY publication_id)
          UNION
          (SELECT publication_id,
                  'w1' as fname_prefix, 
                  array_agg(ngram) as fname,
                  array_agg(count) as fval
            FROM  f_word_1gram 
            GROUP BY publication_id)
          UNION
          (SELECT publication_id,
                  'w3' as fname_prefix, 
                  array_agg(ngram) as fname,
                  array_agg(count) as fval
            FROM  f_word_3gram 
            GROUP BY publication_id)
        ) tmp
      """
    }

    ext_export_json_pub_copy {
      style: "sql_extractor"
      dependencies: ["ext_export_json_pub"]
      sql: """
        COPY(
            select * from export_features_pub
            order by publication_id)
          to '/tmp/deepsaa-pub-features.tsv';

        DROP TABLE IF EXISTS eval_publication_authors CASCADE;

        SELECT publication_id, array_agg(distinct author_id) as authors 
        INTO eval_publication_authors
        FROM sentence_author where IS_TRUE != false or is_true is null GROUP BY publication_id;

        COPY(
          select * from eval_publication_authors
            order by publication_id)
          to '/tmp/deepsaa-pub-authors.tsv';

      """
    }
    # # Set ALL non-authored papers as negative examples
    # # 3539102 negative examples
    # ext_coauthorship {
    #   style: "sql_extractor"
    # }
  }

  # ###############
  # Inference Rules
  # ###############
  inference.factors {

    f_doc_stats {
      input_query: """
          SELECT  pub.id as "publication_author.id",
                  pub.is_true as "publication_author.is_true",
                  (author_id || fname) as "f_doc_stats.fname"
          FROM    f_doc_stats f, 
                  publication_author pub
          WHERE   pub.publication_id = f.publication_id AND
            (
                (fname = 'num_chars_title' and fval >= 58) OR
                (fname = 'num_chars' and fval >= 1111) OR
                (fname = 'avg_word_length' and fval >= 6.23) OR
                (fname = 'num_words' and fval >= 155) 
            )
          """
      function: "IsTrue(publication_author.is_true)"
      weight: "?(f_doc_stats.fname)"
    }
    f_char_1gram {
      input_query: """
          SELECT  pub.id as "publication_author.id",
                  pub.is_true as "publication_author.is_true",
                  (author_id || ngram) as "f_char_1gram.ngram"
          FROM    f_char_1gram f, 
                  publication_author pub
          WHERE   count > 100.0
            AND   pub.publication_id = f.publication_id
          """
      function: "IsTrue(publication_author.is_true)"
      weight: "?(f_char_1gram.ngram)"
    }
    f_char_2gram {
      input_query: """
          SELECT  pub.id as "publication_author.id",
                  pub.is_true as "publication_author.is_true",
                  (author_id || ngram) as "f_char_2gram.ngram"
          FROM    f_char_2gram f, 
                  publication_author pub
          WHERE   count > 20.0
            AND   pub.publication_id = f.publication_id
          """
      function: "IsTrue(publication_author.is_true)"
      weight: "?(f_char_2gram.ngram)"
    }
    f_word_1gram {
      input_query: """
          SELECT  pub.id as "publication_author.id",
                  pub.is_true as "publication_author.is_true",
                  (author_id || ngram) as "f_word_1gram.ngram"
          FROM    f_word_1gram f, 
                  publication_author pub
          WHERE   count > 3.0
            AND   pub.publication_id = f.publication_id
          """
      function: "IsTrue(publication_author.is_true)"
      weight: "?(f_word_1gram.ngram)"
    }
    f_word_3gram {
      input_query: """
          SELECT  pub.id as "publication_author.id",
                  pub.is_true as "publication_author.is_true",
                  (author_id || ngram) as "f_word_3gram.ngram"
          FROM    f_word_3gram f, 
                  publication_author pub
          WHERE   count > 2.0
            AND   pub.publication_id = f.publication_id
          """
      function: "IsTrue(publication_author.is_true)"
      weight: "?(f_word_3gram.ngram)"
    }
    # f_coauthor {
    #   input_query: """
    #   SELECT  a1.id as "sentence_author.a1.id",
    #           a1.is_true as "sentence_author.a1.is_true",
    #           a2.id as "sentence_author.a2.id",
    #           a2.is_true as "sentence_author.a2.is_true"
    #     FROM  sentence_author a1,
    #           sentence_author a2
    #    WHERE  a1.publication_id = a2.publication_id

    #   """
    # }


    # Sentence-level prediction
    f_doc_stats {
      input_query: """
          SELECT  pub.id as "publication_author.id",
                  pub.is_true as "publication_author.is_true",
                  (author_id || fname) as "f_doc_stats.fname"
          FROM    f_doc_stats f, 
                  publication_author pub
          WHERE   pub.publication_id = f.publication_id AND
            (
                (fname = 'num_chars_title' and fval >= 58) OR
                (fname = 'num_chars' and fval >= 1111) OR
                (fname = 'avg_word_length' and fval >= 6.23) OR
                (fname = 'num_words' and fval >= 155) 
            )
          """
      function: "IsTrue(publication_author.is_true)"
      weight: "?(f_doc_stats.fname)"
    }
    f_char_1gram {
      input_query: """
          SELECT  pub.id as "publication_author.id",
                  pub.is_true as "publication_author.is_true",
                  (author_id || ngram) as "f_char_1gram.ngram"
          FROM    f_char_1gram f, 
                  publication_author pub
          WHERE   count > 100.0
            AND   pub.publication_id = f.publication_id
          """
      function: "IsTrue(publication_author.is_true)"
      weight: "?(f_char_1gram.ngram)"
    }
    f_char_2gram {
      input_query: """
          SELECT  pub.id as "publication_author.id",
                  pub.is_true as "publication_author.is_true",
                  (author_id || ngram) as "f_char_2gram.ngram"
          FROM    f_char_2gram f, 
                  publication_author pub
          WHERE   count > 20.0
            AND   pub.publication_id = f.publication_id
          """
      function: "IsTrue(publication_author.is_true)"
      weight: "?(f_char_2gram.ngram)"
    }
    f_word_1gram {
      input_query: """
          SELECT  pub.id as "publication_author.id",
                  pub.is_true as "publication_author.is_true",
                  (author_id || ngram) as "f_word_1gram.ngram"
          FROM    f_word_1gram f, 
                  publication_author pub
          WHERE   count > 3.0
            AND   pub.publication_id = f.publication_id
          """
      function: "IsTrue(publication_author.is_true)"
      weight: "?(f_word_1gram.ngram)"
    }
    f_word_3gram {
      input_query: """
          SELECT  pub.id as "publication_author.id",
                  pub.is_true as "publication_author.is_true",
                  (author_id || ngram) as "f_word_3gram.ngram"
          FROM    f_word_3gram f, 
                  publication_author pub
          WHERE   count > 2.0
            AND   pub.publication_id = f.publication_id
          """
      function: "IsTrue(publication_author.is_true)"
      weight: "?(f_word_3gram.ngram)"
    }
  }

}

# STATS
    # 2265 distinct char 2grams
    # 109977 distinct char 5grams
    # 16709 words
    # 191637 word 3grams
    # 1188 pos 2grams

